#include <iostream>
#include <cmath>

using namespace std;

double f(double x) // Функция y= 
{
	return (x * x) - (2 * x) - (3);
}

double f1(double x) // Первая производная
{
	return (2 * x) - 2;
}

double f2(double x) // Вторая производная
{
	return 2;
}

int main()
{
	setlocale(LC_ALL, "Russian");
	double x1, x, E, a, b;
	cout << "Функция f(x) = y = x^2 + 36*x + 35" << endl; // Корни 1 и 35
	do {
		cout << "Введите границы поиска, в которых точно есть только один корень" << endl;
		cin >> a >> b; // x1 < x (x - это x2 из бинарного поиска)
		if (b < a) // Если пользователь перепутал местами границы отрезка
		{
			x = a;
			a = b;
			b = x;
		}
	} while (f(a) * f(b) > 0); // Функция должна принимать разные знаки на границах отрезков, иначе либо корней нет, либо корня 2, что нам не подходит
	cout << "Введите допустимую погрешность" << endl;
	cin >> E; // Погрешность (эпсилон)
	if (f(a) * f2(a) > 0) x = a; // Ищем x0 (х) на границах отрезка (надо что бы знак функции и её второй производной был одинаковый), берём точку, где функция выпукла
	else x = b;
	x1 = x - f(x) / f1(x); // Делаем уравнение касательной для точки x0 (х), которую мы нашли прошлым шагом
	while (abs(x1-x)>E) // Пока разница между точками больше заданной погрешности, уменьшаем эту самую разницу
	{
		x = x1; // Освобождаем память для x1, потому что x0 у нас уже за границей нового отрезка
		x1 = x - f(x) / f1(x); // Строим заново уравнение касательной для новой точки
	}
	cout << "Ответ: " << x << endl;
	return 0;
}