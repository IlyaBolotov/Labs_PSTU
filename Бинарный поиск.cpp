#include <iostream>

using namespace std;

double f(double x)
{
	return	x * x + 36 * x + 35;
}

int main()
{
	setlocale(LC_ALL, "Russian");
	long double x1, x2, x = 0, E, y1, y2, y = 1; // y определяем, потому что иначе программа может вылететь при входе в цикл
	// x определяем, на случай, если пользователь сразу задаст точность, больше, чем разность по модулю границ поиска и мы не зайдём в цикл.
	// В таком случае программа крашнется, потому что у нас неинициализированная память x
	cout << "Функция f(x) = y = x^2 + 36*x + 35" << endl; // Корни -1 и -35
	do {
		cout << "Введите границы поиска, в которых только один корень" << endl;
		cin >> x1 >> x2; // x1 < x2
		if (x1 > x2) // Проверка на случай, если пользователь перепутал местами границы поиска
		{
			y = x1;
			x1 = x2;
			x2 = y;
		}
	} while (f(x1) * f(x2) > 0); // Проверка на случай, если 2 корня или ни одного
	cout << "Введите допустимую погрешность" << endl;
	cin >> E; //Погрешность	
	while ((x2 - x1 > E) && (y != 0)) // y != 0, потому что если y == 0, то мы нашли корень
	{
		x = (x2 + x1) / 2; // Находим среднее между x1 и x2
		y = f(x); // Находим y в точке x
		if (y != 0) // y != 0, потому что если мы нашли корень, зачем нам это всё делать
		{
			y1 = f(x1); // y1 - y для x1
			y2 = f(x2); // y2 - y для x2
			y = f(x); // y3 - y для x
			if (y1 * y < 0) // Проверяем, в какую сторону идти (если < 0, то корень в промежутке)
			{
				x2 = x; // Заменяем x2 на x, потому что x2 вне промежутка, в котором есть корень
			}
			else if (y2 * y < 0) // то же самое, что и выше, разве промежуток противоположный
			{
				x1 = x;
			}
		}
	}
	cout << "Ответ: " << x << endl; // На вывод можно любой найденный корень
}